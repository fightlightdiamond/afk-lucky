import { PrismaClient, UserRole } from "@prisma/client";
import bcrypt from "bcryptjs";

const prisma = new PrismaClient();

async function main() {
  console.log("üå± Starting comprehensive database seeding...");

  try {
    // B∆Ø·ªöC 1: Seed roles tr∆∞·ªõc (kh√¥ng ph·ª• thu·ªôc g√¨)
    console.log("\nüìã Step 1: Seeding roles...");
    await seedRoles();

    // B∆Ø·ªöC 2: T·∫°o admin user KH√îNG c√≥ group_id (ƒë·ªÉ tr√°nh circular dependency)
    console.log("\nüë§ Step 2: Creating admin user without group...");
    const adminUser = await createAdminUser();

    // B∆Ø·ªöC 3: T·∫°o default group v·ªõi admin l√†m owner
    console.log("\nüè¢ Step 3: Creating default group...");
    const defaultGroup = await createDefaultGroup(adminUser.id);

    // B∆Ø·ªöC 4: C·∫≠p nh·∫≠t admin user v·ªõi group_id
    console.log("\nüîÑ Step 4: Updating admin user with group...");
    await updateAdminUserGroup(adminUser.id, defaultGroup.id);

    // B∆Ø·ªöC 5: T·∫°o c√°c users kh√°c v·ªõi group_id ƒë√£ c√≥
    console.log("\nüë• Step 5: Creating other users...");
    await createOtherUsers(defaultGroup.id);

    // B∆Ø·ªöC 6: Seed story data
    console.log("\nüìñ Step 6: Seeding story templates...");
    await seedStoryTemplates();

    console.log("\nüéØ Step 7: Seeding story versions...");
    await seedStoryVersions();

    // B∆Ø·ªöC 7: Hi·ªÉn th·ªã summary
    await displaySummary();

    console.log("\n‚úÖ Database seeding completed successfully!");
    console.log("\nüìã Sample Login Credentials:");
    console.log("   Admin: admin@example.com / 123456");
    console.log("   Editor: editor@example.com / 123456");
    console.log("   Author: author@example.com / 123456");
    console.log("   Moderator: moderator@example.com / 123456");
    console.log("   User: user@example.com / 123456");
  } catch (error) {
    console.error("‚ùå Seeding failed:", error);
    throw error;
  }
}

// ===== HELPER FUNCTIONS =====

async function seedRoles() {
  const DEFAULT_ROLE_PERMISSIONS = {
    [UserRole.ADMIN]: [
      "users.create",
      "users.read",
      "users.update",
      "users.delete",
      "roles.create",
      "roles.read",
      "roles.update",
      "roles.delete",
      "stories.create",
      "stories.read",
      "stories.update",
      "stories.delete",
      "templates.create",
      "templates.read",
      "templates.update",
      "templates.delete",
      "analytics.read",
      "system.manage",
    ],
    [UserRole.EDITOR]: [
      "stories.create",
      "stories.read",
      "stories.update",
      "stories.delete",
      "templates.read",
      "templates.update",
      "users.read",
    ],
    [UserRole.AUTHOR]: [
      "stories.create",
      "stories.read",
      "stories.update",
      "templates.read",
    ],
    [UserRole.MODERATOR]: [
      "stories.read",
      "stories.update",
      "stories.delete",
      "users.read",
      "templates.read",
    ],
    [UserRole.USER]: ["stories.create", "stories.read", "templates.read"],
  };

  for (const [roleName, permissions] of Object.entries(
    DEFAULT_ROLE_PERMISSIONS
  )) {
    const role = await prisma.role.upsert({
      where: { name: roleName as UserRole },
      update: {
        permissions: {
          set: permissions,
        },
      },
      create: {
        name: roleName as UserRole,
        description: getRoleDescription(roleName as UserRole),
        permissions: {
          set: permissions,
        },
      },
    });

    console.log(
      `‚úÖ Role ${roleName} created/updated with ${permissions.length} permissions`
    );
  }
}

function getRoleDescription(role: UserRole): string {
  const descriptions: Record<UserRole, string> = {
    [UserRole.ADMIN]: "Full system administrator with all permissions",
    [UserRole.EDITOR]: "Content editor with publishing capabilities",
    [UserRole.AUTHOR]: "Content creator with basic editing permissions",
    [UserRole.MODERATOR]:
      "Content moderator with review and management permissions",
    [UserRole.USER]: "Basic user with limited content creation permissions",
  };
  return descriptions[role] || "Standard user role";
}

async function createAdminUser() {
  const adminRole = await prisma.role.findUnique({
    where: { name: UserRole.ADMIN },
  });

  if (!adminRole) {
    throw new Error("Admin role not found");
  }

  const hashedPassword = await bcrypt.hash("123456", 10);

  const adminUser = await prisma.user.upsert({
    where: { email: "admin@example.com" },
    update: {
      first_name: "Admin",
      last_name: "System",
      password: hashedPassword,
      role_id: adminRole.id,
      is_active: true,
      coin: BigInt(10000),
      locale: "vi",
      // Kh√¥ng set group_id ·ªü ƒë√¢y
    },
    create: {
      first_name: "Admin",
      last_name: "System",
      email: "admin@example.com",
      password: hashedPassword,
      role_id: adminRole.id,
      sex: true,
      is_active: true,
      coin: BigInt(10000),
      locale: "vi",
      // Kh√¥ng set group_id ·ªü ƒë√¢y
    },
  });

  console.log(`‚úÖ Admin user created: ${adminUser.email}`);
  return adminUser;
}

async function createDefaultGroup(adminUserId: string) {
  const defaultGroup = await prisma.group.upsert({
    where: { id: 1 },
    update: {
      name: "Default Group",
      ownerId: adminUserId,
    },
    create: {
      id: 1,
      name: "Default Group",
      ownerId: adminUserId,
    },
  });

  console.log(
    `‚úÖ Default group created: ${defaultGroup.name} (Owner: ${adminUserId})`
  );
  return defaultGroup;
}

async function updateAdminUserGroup(adminUserId: string, groupId: number) {
  await prisma.user.update({
    where: { id: adminUserId },
    data: { group_id: groupId },
  });

  console.log(`‚úÖ Admin user updated with group_id: ${groupId}`);
}

async function createOtherUsers(groupId: number) {
  const roles = await prisma.role.findMany();
  const roleMap = new Map(roles.map((role) => [role.name, role.id]));

  const sampleUsers = [
    {
      first_name: "Nguy·ªÖn",
      last_name: "VƒÉn A",
      email: "editor@example.com",
      password: "123456",
      role: UserRole.EDITOR,
      sex: true,
      is_active: true,
      coin: BigInt(5000),
      locale: "vi",
    },
    {
      first_name: "Tr·∫ßn",
      last_name: "Th·ªã B",
      email: "author@example.com",
      password: "123456",
      role: UserRole.AUTHOR,
      sex: false,
      is_active: true,
      coin: BigInt(3000),
      locale: "vi",
    },
    {
      first_name: "L√™",
      last_name: "VƒÉn C",
      email: "moderator@example.com",
      password: "123456",
      role: UserRole.MODERATOR,
      sex: true,
      is_active: true,
      coin: BigInt(2000),
      locale: "vi",
    },
    {
      first_name: "Ph·∫°m",
      last_name: "Th·ªã D",
      email: "user@example.com",
      password: "123456",
      role: UserRole.USER,
      sex: false,
      is_active: true,
      coin: BigInt(1000),
      locale: "vi",
    },
    {
      first_name: "Ho√†ng",
      last_name: "VƒÉn E",
      email: "inactive@example.com",
      password: "123456",
      role: UserRole.USER,
      sex: true,
      is_active: false,
      coin: BigInt(500),
      locale: "en",
    },
  ];

  for (const userData of sampleUsers) {
    const hashedPassword = await bcrypt.hash(userData.password, 10);
    const roleId = roleMap.get(userData.role);

    if (!roleId) {
      console.warn(
        `‚ö†Ô∏è  Role ${userData.role} not found, skipping user ${userData.email}`
      );
      continue;
    }

    await prisma.user.upsert({
      where: { email: userData.email },
      update: {
        first_name: userData.first_name,
        last_name: userData.last_name,
        password: hashedPassword,
        role_id: roleId,
        sex: userData.sex,
        is_active: userData.is_active,
        coin: userData.coin,
        locale: userData.locale,
        group_id: groupId,
      },
      create: {
        first_name: userData.first_name,
        last_name: userData.last_name,
        email: userData.email,
        password: hashedPassword,
        role_id: roleId,
        sex: userData.sex,
        is_active: userData.is_active,
        coin: userData.coin,
        locale: userData.locale,
        group_id: groupId,
      },
    });

    console.log(
      `‚úÖ User created/updated: ${userData.email} (${userData.role})`
    );
  }
}

async function seedStoryTemplates() {
  const templates = [
    {
      name: "C√¢u chuy·ªán c√¥ng ngh·ªá",
      description: "T·∫°o c√¢u chuy·ªán v·ªÅ c√¥ng ngh·ªá v√† ƒë·ªïi m·ªõi",
      icon: "üíª",
      category: "tech",
      config: {
        tone: "professional",
        style: "informative",
        target_audience: "tech_enthusiasts",
      },
      popular: true,
    },
    {
      name: "C√¢u chuy·ªán kinh doanh",
      description: "C√¢u chuy·ªán v·ªÅ kh·ªüi nghi·ªáp v√† kinh doanh",
      icon: "üíº",
      category: "business",
      config: {
        tone: "motivational",
        style: "narrative",
        target_audience: "entrepreneurs",
      },
      popular: true,
    },
    {
      name: "C√¢u chuy·ªán cu·ªôc s·ªëng",
      description: "Nh·ªØng c√¢u chuy·ªán v·ªÅ cu·ªôc s·ªëng h√†ng ng√†y",
      icon: "üåü",
      category: "life",
      config: {
        tone: "casual",
        style: "personal",
        target_audience: "general",
      },
      popular: false,
    },
    {
      name: "C√¢u chuy·ªán gi√°o d·ª•c",
      description: "C√¢u chuy·ªán mang t√≠nh gi√°o d·ª•c v√† h·ªçc t·∫≠p",
      icon: "üìö",
      category: "education",
      config: {
        tone: "educational",
        style: "structured",
        target_audience: "students",
      },
      popular: true,
    },
  ];

  for (const template of templates) {
    // Ki·ªÉm tra xem template ƒë√£ t·ªìn t·∫°i ch∆∞a
    const existing = await prisma.storyTemplate.findFirst({
      where: { name: template.name },
    });

    if (existing) {
      await prisma.storyTemplate.update({
        where: { id: existing.id },
        data: template,
      });
      console.log(`‚úÖ Template updated: ${template.name}`);
    } else {
      await prisma.storyTemplate.create({
        data: template,
      });
      console.log(`‚úÖ Template created: ${template.name}`);
    }
  }
}

async function seedStoryVersions() {
  const versions = [
    {
      name: "Simple",
      slug: "simple",
      description: "Phi√™n b·∫£n c∆° b·∫£n v·ªõi c√°c t√≠nh nƒÉng thi·∫øt y·∫øu",
      icon: "üå±",
      color_scheme: "blue",
      features: [
        { name: "T·∫°o c√¢u chuy·ªán c∆° b·∫£n", available: true },
        { name: "3 template mi·ªÖn ph√≠", available: true },
        { name: "Xu·∫•t PDF", available: true },
      ],
      limitations: [
        { name: "T·ªëi ƒëa 5 c√¢u chuy·ªán/ng√†y", limit: 5 },
        { name: "T·ªëi ƒëa 500 t·ª´/c√¢u chuy·ªán", limit: 500 },
      ],
      is_free: true,
      max_stories_per_day: 5,
      max_word_count: 500,
      available_templates: [],
      available_languages: ["vi", "en"],
      advanced_features: {
        custom_templates: false,
        advanced_export: false,
        analytics: false,
      },
    },
    {
      name: "Advanced",
      slug: "advanced",
      description: "Phi√™n b·∫£n n√¢ng cao v·ªõi nhi·ªÅu t√≠nh nƒÉng h∆°n",
      icon: "üöÄ",
      color_scheme: "purple",
      features: [
        { name: "T·∫°o c√¢u chuy·ªán n√¢ng cao", available: true },
        { name: "T·∫•t c·∫£ templates", available: true },
        { name: "Xu·∫•t ƒëa ƒë·ªãnh d·∫°ng", available: true },
        { name: "Ph√¢n t√≠ch chi ti·∫øt", available: true },
      ],
      limitations: [
        { name: "T·ªëi ƒëa 20 c√¢u chuy·ªán/ng√†y", limit: 20 },
        { name: "T·ªëi ƒëa 2000 t·ª´/c√¢u chuy·ªán", limit: 2000 },
      ],
      is_free: false,
      price_monthly: 99000,
      price_yearly: 990000,
      max_stories_per_day: 20,
      max_word_count: 2000,
      available_templates: [],
      available_languages: ["vi", "en", "ja", "ko"],
      advanced_features: {
        custom_templates: true,
        advanced_export: true,
        analytics: true,
      },
    },
  ];

  for (const version of versions) {
    await prisma.storyVersion.upsert({
      where: { slug: version.slug },
      update: version,
      create: version,
    });
    console.log(`‚úÖ Version created/updated: ${version.name}`);
  }
}

async function displaySummary() {
  console.log("\nüìä Seeding Summary:");

  const userCount = await prisma.user.count();
  const roleCount = await prisma.role.count();
  const groupCount = await prisma.group.count();
  const templateCount = await prisma.storyTemplate.count();
  const versionCount = await prisma.storyVersion.count();

  console.log(`   - Roles: ${roleCount}`);
  console.log(`   - Groups: ${groupCount}`);
  console.log(`   - Users: ${userCount}`);
  console.log(`   - Story Templates: ${templateCount}`);
  console.log(`   - Story Versions: ${versionCount}`);
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
